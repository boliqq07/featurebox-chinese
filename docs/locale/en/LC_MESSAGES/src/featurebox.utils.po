# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, boliqq07
# This file is distributed under the same license as the featurebox package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: featurebox \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-24 10:33+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../src/featurebox.utils.rst:2
msgid "featurebox.utils package"
msgstr ""

#: ../../src/featurebox.utils.rst:10
msgid "Submodules"
msgstr ""

#: ../../src/featurebox.utils.rst:13
msgid "featurebox.utils.look\\_json module"
msgstr ""

#: featurebox.utils.look_json:1 of
msgid ""
"This part is used to add as_json and to_json method for Externally class."
" In default, for one case, we add by inherit monty.json.MSONable. but for"
" large mount cases, it rewrite a lot of things. This is a dynamic "
"approach, For a small amount of work, we don't recommend it."
msgstr ""

#: featurebox.utils.look_json:7 featurebox.utils.look_json.get_marked_class:11
#: of
msgid "Examples"
msgstr ""

#: featurebox.utils.look_json:8 of
msgid "#In definition code."
msgstr ""

#: featurebox.utils.look_json:14 of
msgid "# Usage code"
msgstr ""

#: featurebox.utils.look_json:18 of
msgid "The new class are marked with \"_D\""
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:1 of
msgid "Bases: :class:`json.encoder.JSONEncoder`"
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:1 of
msgid ""
"A Json Encoder which supports the MSONable API, plus adds support for "
"numpy arrays, datetime objects, bson ObjectIds (requires bson)."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:4 of
msgid "Usage::"
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:9 of
msgid "Constructor for JSONEncoder, with sensible defaults."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:11 of
msgid ""
"If skipkeys is false, then it is a TypeError to attempt encoding of keys "
"that are not str, int, float or None.  If skipkeys is True, such items "
"are simply skipped."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:15 of
msgid ""
"If ensure_ascii is true, the output is guaranteed to be str objects with "
"all incoming non-ASCII characters escaped.  If ensure_ascii is false, the"
" output can contain non-ASCII characters."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:19 of
msgid ""
"If check_circular is true, then lists, dicts, and custom encoded objects "
"will be checked for circular references during encoding to prevent an "
"infinite recursion (which would cause an OverflowError). Otherwise, no "
"such check takes place."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:24 of
msgid ""
"If allow_nan is true, then NaN, Infinity, and -Infinity will be encoded "
"as such.  This behavior is not JSON specification compliant, but is "
"consistent with most JavaScript based encoders and decoders. Otherwise, "
"it will be a ValueError to encode such floats."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:29 of
msgid ""
"If sort_keys is true, then the output of dictionaries will be sorted by "
"key; this is useful for regression tests to ensure that JSON "
"serializations can be compared on a day-to-day basis."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:33 of
msgid ""
"If indent is a non-negative integer, then JSON array elements and object "
"members will be pretty-printed with that indent level.  An indent level "
"of 0 will only insert newlines. None is the most compact representation."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:38 of
msgid ""
"If specified, separators should be an (item_separator, key_separator) "
"tuple.  The default is (', ', ': ') if *indent* is ``None`` and (',', ': "
"') otherwise.  To get the most compact JSON representation, you should "
"specify (',', ':') to eliminate whitespace."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder:43 of
msgid ""
"If specified, default is a function that gets called for objects that "
"can't otherwise be serialized.  It should return a JSON encodable version"
" of the object or raise a ``TypeError``."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder.default:1 of
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for ``o``, or calls the base implementation (to raise a "
"``TypeError``)."
msgstr ""

#: featurebox.utils.look_json.UserMontyEncoder.default:5 of
msgid ""
"For example, to support arbitrary iterators, you could implement default "
"like this::"
msgstr ""

#: featurebox.utils.look_json.as_dict:1 of
msgid "A JSON serializable dict representation of an object."
msgstr ""

#: featurebox.utils.look_json.get_marked_class:1 of
msgid ""
"Just call values in NNict by,consider multiple cases at the same time. "
"[\"VoronoiNN\", VoronoiNN, VoronoiNN(), \"VoronoiNN_D\", VoronoiNN_D, "
"VoronoiNN_D(),] All map VoronoiNN_D() or VoronoiNN_D."
msgstr ""

#: featurebox.utils.look_json.get_marked_class:12 of
msgid "# In definition code. # NNDict = mark_classes([VoronoiNN,CutOffDictNN])"
msgstr ""

#: featurebox.utils.look_json.get_marked_class:17
#: featurebox.utils.look_json.mark_classes:7 of
msgid "for i, j in NNDict.items():"
msgstr ""

#: featurebox.utils.look_json.get_marked_class:17
#: featurebox.utils.look_json.mark_classes:6 of
msgid "locals()[i] = j"
msgstr ""

#: featurebox.utils.look_json.get_marked_class:19 of
msgid "# Usage code # vor = get_marked_class(\"VoronoiNN\", NNDict)"
msgstr ""

#: featurebox.utils.look_json.get_marked_class
#: featurebox.utils.look_json.mark_classes of
msgid "Parameters"
msgstr ""

#: featurebox.utils.look_json.get_marked_class:23 of
msgid "str or class in NNDict."
msgstr ""

#: featurebox.utils.look_json.get_marked_class:24 of
msgid "dict of pre-definition, {\"classname_D\": class}."
msgstr ""

#: featurebox.utils.look_json.get_marked_class:26 of
msgid "return class of object."
msgstr ""

#: featurebox.utils.look_json.get_marked_class
#: featurebox.utils.look_json.mark_classes of
msgid "Returns"
msgstr ""

#: featurebox.utils.look_json.get_marked_class:29 of
msgid "object or class in NNDict."
msgstr ""

#: featurebox.utils.look_json.get_marked_class
#: featurebox.utils.look_json.mark_classes of
msgid "Return type"
msgstr ""

#: featurebox.utils.look_json.mark_classes:1 of
msgid "Batch add as_json and to_json method for Externally class."
msgstr ""

#: featurebox.utils.look_json.mark_classes:3 of
msgid "NNDict = mark_classes([VoronoiNN,CutOffDictNN])"
msgstr ""

#: featurebox.utils.look_json.mark_classes:9 of
msgid "not object."
msgstr ""

#: featurebox.utils.look_json.mark_classes:12 of
msgid ""
"key is the class name with append \"_D\", and values is the new class "
"with `as_json` method."
msgstr ""

#: featurebox.utils.look_json.to_json:1 of
msgid "Returns a json string representation of the MSONable object."
msgstr ""

#: ../../src/featurebox.utils.rst:21
msgid "featurebox.utils.predefined\\_typing module"
msgstr ""

#: ../../src/featurebox.utils.rst:29
msgid "featurebox.utils.quickmethod module"
msgstr ""

#: featurebox.utils.quickmethod:1 of
msgid "This is script, copy for using, rather than call.**"
msgstr ""

#: featurebox.utils.quickmethod.dict_method_clf:1 of
msgid "many clf method."
msgstr ""

#: featurebox.utils.quickmethod.dict_method_reg:1 of
msgid "many reg method."
msgstr ""

#: featurebox.utils.quickmethod.method_pack:1 of
msgid "return cv or gd."
msgstr ""

#~ msgid "Define several typing for convenient use"
#~ msgstr ""

